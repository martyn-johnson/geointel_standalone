<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>GeoIntel Standalone</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    header { display:flex; align-items:center; gap:.5rem; padding:.5rem 1rem; border-bottom:1px solid #ddd; }
    main { display:grid; grid-template-columns: 360px 1fr; height: calc(100vh - 56px); }
    #list { overflow:auto; border-right:1px solid #ddd; }
    #map { height: 100%; }
    .item { padding:8px 12px; border-bottom:1px solid #eee; cursor:pointer; }
    .item:hover { background:#f7f7f7; }
    .badge { font-size: 11px; padding: 2px 6px; border-radius: 999px; background: #eee; margin-left: 6px; }
    .controls { margin-left:auto; display:flex; gap:.5rem; align-items:center; flex-wrap: wrap; }
    .status { font-size:12px; opacity:.7; }
    .mode { font-size:12px; opacity:.8; padding:2px 6px; border:1px dashed #aaa; border-radius: 6px; }
  </style>
</head>
<body>
<header>
  <h3 style="margin:0">GeoIntel Standalone</h3>
  <div class="controls">
    <button id="set-base">Set Base</button>
    <button id="clear-base">Clear Base</button>
    <button id="set-bbox">Set BBox</button>
    <button id="clear-bbox">Clear BBox</button>
    <label><input id="likely-only" type="checkbox" checked> Likely only</label>
    <button id="refresh">Refresh</button>
    <span id="live-status" class="status">live: connecting…</span>
    <span id="mode" class="mode" style="display:none;"></span>
  </div>
</header>
<main>
  <aside id="list"></aside>
  <section id="map"></section>
</main>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
let map, markers, baseLatLon = null, settingBase = false, baseMarker = null;
let es = null;

// BBox state
let settingBBox = false;
let bboxFirst = null;   // first corner LatLng
let bboxRect = null;    // Leaflet rectangle

function setModeText(txt) {
  const el = document.getElementById('mode');
  if (!el) return;
  if (txt) { el.textContent = txt; el.style.display = ''; }
  else { el.textContent = ''; el.style.display = 'none'; }
}

function initMap() {
  map = L.map('map').setView([51.5, -0.12], 6);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap'
  }).addTo(map);
  markers = L.layerGroup().addTo(map);

  map.on('click', async e => {
    // Base placement mode takes precedence
    if (settingBase) {
      const lat = e.latlng.lat, lon = e.latlng.lng;
      try {
        const r = await fetch('/api/base', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({lat, lon})
        });
        const js = await r.json();
        if (js && js.base) {
          baseLatLon = [js.base.lat, js.base.lon];
          drawBaseMarker();
          alert('Base set to ' + baseLatLon.join(','));
        } else {
          alert('Failed to set base');
        }
      } catch (err) {
        alert('Error setting base: ' + err);
      } finally {
        settingBase = false;
        setModeText(null);
      }
      return;
    }

    // BBox placement mode: two clicks = opposite corners
    if (settingBBox) {
      if (!bboxFirst) {
        bboxFirst = e.latlng;
        setModeText('BBox: click second corner…');
      } else {
        const a = bboxFirst, b = e.latlng;
        bboxFirst = null;
        settingBBox = false;
        setModeText(null);

        const lat1 = Math.min(a.lat, b.lat);
        const lat2 = Math.max(a.lat, b.lat);
        const lon1 = Math.min(a.lng, b.lng);
        const lon2 = Math.max(a.lng, b.lng);

        try {
          const r = await fetch('/api/bbox', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({lat1, lat2, lon1, lon2})
          });
          const js = await r.json();
          if (js && js.bbox) {
            drawBBoxRect(js.bbox);
            alert('BBox set.');
          } else if (js && js.error) {
            alert('Failed to set BBox: ' + js.error);
          } else {
            alert('Failed to set BBox.');
          }
        } catch (err) {
          alert('Error setting BBox: ' + err);
        }
      }
    }
  });
}

function drawBaseMarker() {
  if (!map) return;
  if (baseMarker) {
    map.removeLayer(baseMarker);
    baseMarker = null;
  }
  if (baseLatLon) {
    baseMarker = L.marker(baseLatLon, { title: 'Base' }).addTo(map);
  }
}

function drawBBoxRect(bbox) {
  if (!map) return;
  if (bboxRect) {
    map.removeLayer(bboxRect);
    bboxRect = null;
  }
  if (bbox && typeof bbox.lat1 === 'number' && typeof bbox.lat2 === 'number'
           && typeof bbox.lon1 === 'number' && typeof bbox.lon2 === 'number') {
    const southWest = L.latLng(bbox.lat1, bbox.lon1);
    const northEast = L.latLng(bbox.lat2, bbox.lon2);
    const bounds = L.latLngBounds(southWest, northEast);
    bboxRect = L.rectangle(bounds, { weight: 2, fillOpacity: 0.05 });
    bboxRect.addTo(map);
  }
}

async function loadBase() {
  try {
    const r = await fetch('/api/base', { cache: 'no-store' });
    const js = await r.json();
    if (js && js.base) {
      baseLatLon = [js.base.lat, js.base.lon];
    } else {
      baseLatLon = null;
    }
    drawBaseMarker();
  } catch (e) {
    // base is optional; ignore errors
  }
}

async function loadBBox() {
  try {
    const r = await fetch('/api/bbox', { cache: 'no-store' });
    const js = await r.json();
    if (js && js.bbox) {
      drawBBoxRect(js.bbox);
    } else {
      drawBBoxRect(null);
    }
  } catch (e) {
    // bbox is optional; ignore errors
  }
}

async function fetchSummary() {
  const r = await fetch('/api/summary', {cache:'no-store'});
  const js = await r.json();
  return js.items || [];
}

function renderList(items) {
  const list = document.getElementById('list');
  list.innerHTML = '';
  for (const it of items) {
    const div = document.createElement('div');
    div.className = 'item';
    const when = it.ts ? new Date(it.ts * 1000).toLocaleString() : '';

    const ssidsTxt = (it.ssids && it.ssids.length)
      ? it.ssids.slice(0,6).join(', ')
      : (it.ssid_count && it.ssid_count > 0
          ? '<i>wildcard-only probes (' + it.ssid_count + ')</i>'
          : '<i>no probes</i>');

    div.innerHTML = '<strong>' + it.mac + '</strong>'
      + (when ? '<span class="badge">' + when + '</span>' : '')
      + '<div>' + ssidsTxt + '</div>';

    div.onclick = () => loadCandidates(it.mac);
    list.appendChild(div);
  }
}

async function loadCandidates(mac) {
  markers.clearLayers();
  const params = new URLSearchParams({mac});
  const likelyOnly = document.getElementById('likely-only').checked ? '1' : '0';
  params.set('likely_only', likelyOnly);

  const r = await fetch('/api/candidates?' + params.toString());
  const js = await r.json();
  const items = js.candidates || [];
  let bounds = [];
  for (const c of items) {
    const ll = [c.lat, c.lon];
    const m = L.circleMarker(ll, { radius: Math.max(4, 12 * (c.score || 0.2)) });
    m.bindTooltip(c.ssid + '<br/>score: ' + (c.score||0).toFixed(3));
    markers.addLayer(m);
    bounds.push(ll);
  }
  // also include base marker in fit if present
  if (baseLatLon) bounds.push(baseLatLon);
  if (bboxRect) {
    const b = bboxRect.getBounds();
    bounds.push(b.getSouthWest()); bounds.push(b.getNorthEast());
  }
  if (bounds.length) map.fitBounds(bounds, {maxZoom: 13});
}

async function refresh() {
  const items = await fetchSummary();
  renderList(items);
}

function startLiveSummary() {
  const statusEl = document.getElementById('live-status');
  if (!!window.EventSource) {
    es = new EventSource('/api/stream/summary');
    es.onopen = () => { if (statusEl) statusEl.textContent = 'live: connected'; };
    es.onmessage = (ev) => {
      try {
        const js = JSON.parse(ev.data);
        renderList(js.items || []);
      } catch (_) {}
    };
    es.onerror = (_e) => {
      // EventSource auto-reconnects. Update status text.
      if (statusEl) statusEl.textContent = 'live: reconnecting…';
    };
  } else {
    if (statusEl) statusEl.textContent = 'live: not supported (falling back)';
    // Fallback polling
    refresh();
    setInterval(refresh, 5000);
  }
}

// Controls
document.getElementById('set-base').onclick = () => {
  settingBase = true;
  settingBBox = false; bboxFirst = null;
  setModeText('Base: click map to set…');
};

document.getElementById('clear-base').onclick = async () => {
  try {
    await fetch('/api/base', { method: 'DELETE' });
    baseLatLon = null;
    drawBaseMarker();
  } catch (e) {}
};

document.getElementById('set-bbox').onclick = () => {
  settingBBox = true;
  settingBase = false;
  bboxFirst = null;
  setModeText('BBox: click first corner…');
};

document.getElementById('clear-bbox').onclick = async () => {
  try {
    await fetch('/api/bbox', { method: 'DELETE' });
    drawBBoxRect(null);
  } catch (e) {}
  setModeText(null);
};

// Manual refresh still useful
document.getElementById('refresh').onclick = refresh;

// Boot
initMap();
loadBase();
loadBBox();
// SSE live summary (initial snapshot comes from the stream)
startLiveSummary();
</script>
</body>
</html>
